// Akira-style trailing lights effect with motion blur feedback
// Requires ping-pong buffers for temporal accumulation

// ===== REQUIRED OBS UNIFORMS =====
uniform float4x4 ViewProj;
uniform texture2d image;           // Current frame input
uniform float2 uv_offset;
uniform float2 uv_scale;
uniform float2 uv_size;
uniform float2 uv_pixel_interval;
uniform float elapsed_time;

// ===== PING-PONG BUFFER =====
uniform texture2d previous_frame;  // Previous accumulated frame

// ===== CUSTOM PARAMETERS =====
uniform float trail_length<
    string label = "Trail Length";
    string widget_type = "slider";
    string group = "Trail Settings";
    float minimum = 0.0;
    float maximum = 0.99;
    float step = 0.01;
> = 0.85;

uniform float brightness_threshold<
    string label = "Brightness Threshold";
    string widget_type = "slider";
    string group = "Trail Settings";
    float minimum = 0.0;
    float maximum = 1.0;
    float step = 0.01;
> = 0.3;

uniform float glow_intensity<
    string label = "Glow Intensity";
    string widget_type = "slider";
    string group = "Trail Settings";
    float minimum = 0.0;
    float maximum = 5.0;
    float step = 0.1;
> = 2.0;

uniform float4 trail_tint<
    string label = "Trail Color Tint";
    string widget_type = "color";
    string group = "Trail Settings";
> = {1.0, 0.95, 1.1, 1.0};

uniform bool enable_color_shift<
    string label = "Enable Psychedelic Color Shift";
    string group = "Trail Settings";
> = true;

// ===== SAMPLER STATE =====
sampler_state textureSampler {
    Filter    = Linear;
    AddressU  = Clamp;
    AddressV  = Clamp;
};

// ===== DATA STRUCTURES =====
struct VertexIn {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

struct VertexOut {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

// ===== VERTEX SHADER =====
VertexOut VSDefault(VertexIn v_in)
{
    VertexOut v_out;
    v_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    v_out.uv = v_in.uv * uv_scale + uv_offset;
    return v_out;
}

// ===== HELPER FUNCTIONS =====
float3 rgb2hsv(float3 rgb)
{
    float4 K = float4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
    float4 p = lerp(float4(rgb.bg, K.wz), float4(rgb.gb, K.xy), step(rgb.b, rgb.g));
    float4 q = lerp(float4(p.xyw, rgb.r), float4(rgb.r, p.yzx), step(p.x, rgb.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float3 hsv2rgb(float3 hsv)
{
    float4 K = float4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
    float3 p = abs(frac(hsv.xxx + K.xyz) * 6.0 - K.www);
    return hsv.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);
}

// ===== MULTI-PASS RENDERING OPTIONS =====
// This effect provides multiple pixel shaders for different rendering approaches:
//
// Current (Single Pass): Direct trail accumulation
//   technique Draw { pass { pixel_shader = PSTrailAccumulation; } }
//
// Alternative (Bright Pass First): Extract bright areas, then accumulate
//   Modify technique to use PSBrightPass in first pass
//
// Advanced (Full Composite): Bright extraction + accumulation + final composite
//   Add PSFinalComposite as a third pass to blend with original
//
// To use different approaches, modify the technique block at the bottom of this file.
// The current implementation uses single-pass for simplicity and performance.

// ===== PIXEL SHADER: BRIGHT PASS =====
float4 PSBrightPass(VertexOut v_in) : TARGET
{
    float4 color = image.Sample(textureSampler, v_in.uv);

    // Calculate luminance
    float brightness = dot(color.rgb, float3(0.2126, 0.7152, 0.0722));

    // Extract bright areas
    if (brightness > brightness_threshold) {
        float intensity = (brightness - brightness_threshold) / (1.0 - brightness_threshold);
        color.rgb *= glow_intensity * intensity;
        return color;
    }

    return float4(0.0, 0.0, 0.0, 0.0);
}

// ===== PIXEL SHADER: TRAIL ACCUMULATION =====
float4 PSTrailAccumulation(VertexOut v_in) : TARGET
{
    // Sample current frame
    float4 current = image.Sample(textureSampler, v_in.uv);

    // Sample previous accumulated frame
    float4 prev = previous_frame.Sample(textureSampler, v_in.uv);

    // Fade previous frame
    prev.rgb *= trail_length;

    // Optional color shift for psychedelic effect
    if (enable_color_shift) {
        float3 hsv = rgb2hsv(prev.rgb);
        hsv.x = frac(hsv.x + 0.002); // Slight hue shift
        hsv.y = saturate(hsv.y * 1.05); // Increase saturation slightly
        prev.rgb = hsv2rgb(hsv);
    }

    // Apply color tint to trails
    prev.rgb *= trail_tint.rgb;

    // Composite: add bright current frame to faded trails
    float4 result = current + prev;

    return result;
}

// ===== PIXEL SHADER: FINAL COMPOSITE =====
float4 PSFinalComposite(VertexOut v_in) : TARGET
{
    // Sample original input
    float4 original = image.Sample(textureSampler, v_in.uv);

    // Sample accumulated trails
    float4 trails = previous_frame.Sample(textureSampler, v_in.uv);

    // Blend trails over original
    float4 result = original + trails;
    result.a = original.a;

    return result;
}

// ===== TECHNIQUE (SINGLE PASS TRAIL) =====
// Modify this to use PSBrightPass or PSFinalComposite for different effects
technique Draw
{
    pass TrailAccumulation
    {
        vertex_shader = VSDefault(v_in);
        pixel_shader  = PSTrailAccumulation(v_in);
    }
}